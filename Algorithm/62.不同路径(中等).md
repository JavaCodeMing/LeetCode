```text
题目:
    一个机器人位于一个 m x n 网格的左上角;
    机器人每次只能向下或者向右移动一步,机器人试图达到网格的右下角;
    问总共有多少条不同的路径?
1.动态规划:
    [1]思路:
        (1)dp[i][j]表示从原点(0,0)到坐标位置(i,j)的路线总和;
        (2)因为只能往下或往右走,因此从原点到(i,j)的路线总和等于原点到(i-1,j)的路线的总和加原点到(i,j-1)的路线的总和;
            因此得到动态转移方程: dp[i][j]=dp[i-1][j]+dp[i][j-1] (i>=1,j>=1)
        (3)对i=0或j=0单独分析:
            1)i=0对应dp[0][j]即为第一行,从原点到(0,j)只能是一直往右,最终只有一条路径,即dp[0][j]=1;
            2)j=0对应dp[i][0]即为第一列,从原点到(i,0)只能是一致往下,最终只有一条路径,即dp[i][0]=1;
    [2]实现:
        class Solution {
            public int uniquePaths(int m, int n) {
                int[][] dp = new int[m][n];
                // 填充第一列
                for (int i = 0; i < m; i++) {
                    dp[i][0] = 1;
                }
                // 填充第一行
                for (int j = 0; j < n; j++) {
                    dp[0][j] = 1;
                }
                // 遍历计算原点到每个位置的路径总和
                for (int i = 1; i < m; i++) {
                    for (int j = 1; j < n; j++) {
                        dp[i][j] = dp[i-1][j]+dp[i][j-1];
                    }
                }
                return dp[m-1][n-1];
            }
        }
    [3]复杂度分析:
        (1)时间复杂度: O(m*n),m为行数,n为列数
        (2)空间复杂度: O(m*n)
```
```text
题目:
    实现获取下一个排列的函数,算法需要将给定数字序列重新排列成字典序中下一个更大的排列;
    如果不存在下一个更大的排列,则将数字重新排列成最小的排列(即升序排列);
    必须原地修改,只允许使用额外常数空间;
    案例: (输入位于左侧列,其相应输出位于右侧列)
        1,2,3 → 1,3,2
        3,2,1 → 1,2,3
        1,1,5 → 1,5,1
1.遍历搜索+数组反转:
    [1]思路:
        (1)题目翻译过来就是找出大于给定数组构成的数值的最小值(由数组元素重排序后构成);
        (2)判断是否存在大于给定数组构成的数值的最小值的方法: 从个位向高位遍历,若是递增序列,则不存在,否则存在;
        (3)若存在,则找到第一个小于前值的元素(A元素),在该元素的右边找到大于该元素值的最小元素(B元素),
            取出A和B元素,将B元素放在A元素的位置(保证了从左到该元素构成的值是大于原值(同等长度)的最小值)
        (4)接下来就是要保证除掉B元素新位置的右边的元素加上A元素要构成最小序列,方法如下:
            B元素新位置的右边的元素加上A元素构成最大序列,再将其反转就成了最小序列;
            (而B元素新位置的右边的元素原本从右到左就是递增的,将A元素插入到B元素原来位置后也是递增的)
    [2]实现:
        class Solution {
            public void nextPermutation(int[] nums) {
                // 定义一个变量用来保存大于给定数组构成的数值的最小值
                int i = nums.length - 2;
                // 找出大于给定数组构成的数值的最小值
                while (i >= 0 && nums[i] >= nums[i + 1]) {
                    i--;
                }
                // 如果i大于等于0,则说明存在大于给定数组构成的数值的最小值
                if (i >= 0) {
                    int j = nums.length - 1;
                    // 从右到左遍历,找到第一个大于index的值即为大于给定数组构成的数值的最小值
                    while (j >= 0 && nums[j] <= nums[i]) {
                        j--;
                    }
                    // 此时i对应的值为A元素,j对应的值为B元素,交换两元素
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                }
                // 对i位置的右边的元素进行反转
                int k = i + 1, n = nums.length - 1;
                while (k < n) {
                    int temp = nums[k];
                    nums[k] = nums[n];
                    nums[n] = temp;
                    k++;
                    n--;
                }
            }
        }
    [3]复杂度分析:
        (1)时间复杂度: O(N),N为数组的长度
        (2)空间复杂度: O(1)
```